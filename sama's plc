#!/usr/bin/env python3
from __future__ import print_function
import struct
import sys
import argparse
import math
import json
import uuid
import threading
import os
import csv
import time
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer


PythonGateways = 'pythonGateways/'
sys.path.append(PythonGateways)

import VsiCommonPythonApi as vsiCommonPythonApi
import VsiTcpUdpPythonGateway as vsiEthernetPythonGateway


class MySignals:
    def __init__(self):
        # Inputs
        self.S1_ready = 0
        self.S1_busy = 0
        self.S1_fault = 0
        self.S1_done = 0
        self.S1_cycle_time_ms = 0
        self.S1_inventory_ok = 0
        self.S1_any_arm_failed = 0
        self.S2_ready = 0
        self.S2_busy = 0
        self.S2_fault = 0
        self.S2_done = 0
        self.S2_cycle_time_ms = 0
        self.S2_completed = 0
        self.S2_scrapped = 0
        self.S2_reworks = 0
        self.S2_cycle_time_avg_s = 0
        self.S3_ready = 0
        self.S3_busy = 0
        self.S3_fault = 0
        self.S3_done = 0
        self.S3_cycle_time_ms = 0
        self.S3_strain_relief_ok = 0
        self.S3_continuity_ok = 0
        self.S4_ready = 0
        self.S4_busy = 0
        self.S4_fault = 0
        self.S4_done = 0
        self.S4_cycle_time_ms = 0
        self.S4_total = 0
        self.S4_completed = 0
        self.S5_ready = 0
        self.S5_busy = 0
        self.S5_fault = 0
        self.S5_done = 0
        self.S5_cycle_time_ms = 0
        self.S5_accept = 0
        self.S5_reject = 0
        self.S5_last_accept = 0
        self.S6_ready = 0
        self.S6_busy = 0
        self.S6_fault = 0
        self.S6_done = 0
        self.S6_cycle_time_ms = 0
        self.S6_packages_completed = 0
        self.S6_arm_cycles = 0
        self.S6_total_repairs = 0
        self.S6_operational_time_s = 0
        self.S6_downtime_s = 0
        self.S6_availability = 0

        # Outputs
        self.S1_cmd_start = 0
        self.S1_cmd_stop = 0
        self.S1_cmd_reset = 0
        self.S1_batch_id = 0
        self.S1_recipe_id = 0
        self.S2_cmd_start = 0
        self.S2_cmd_stop = 0
        self.S2_cmd_reset = 0
        self.S2_batch_id = 0
        self.S2_recipe_id = 0
        self.S3_cmd_start = 0
        self.S3_cmd_stop = 0
        self.S3_cmd_reset = 0
        self.S3_batch_id = 0
        self.S3_recipe_id = 0
        self.S4_cmd_start = 0
        self.S4_cmd_stop = 0
        self.S4_cmd_reset = 0
        self.S4_batch_id = 0
        self.S4_recipe_id = 0
        self.S5_cmd_start = 0
        self.S5_cmd_stop = 0
        self.S5_cmd_reset = 0
        self.S5_batch_id = 0
        self.S5_recipe_id = 0
        self.S6_cmd_start = 0
        self.S6_cmd_stop = 0
        self.S6_cmd_reset = 0
        self.S6_batch_id = 0
        self.S6_recipe_id = 0



srcMacAddress = [0x02, 0x00, 0x00, 0x00, 0x00, 0x01]
ST1_ComponentKittingMacAddress = [0x02, 0x00, 0x00, 0x00, 0x00, 0x11]
ST2_FrameCoreAssemblyMacAddress = [0x02, 0x00, 0x00, 0x00, 0x00, 0x12]
ST3_ElectronicsWiringMacAddress = [0x02, 0x00, 0x00, 0x00, 0x00, 0x13]
ST4_CalibrationTestingMacAddress = [0x02, 0x00, 0x00, 0x00, 0x00, 0x14]
ST5_QualityInspectionMacAddress = [0x02, 0x00, 0x00, 0x00, 0x00, 0x15]
ST6_PackagingDispatchMacAddress = [0x02, 0x00, 0x00, 0x00, 0x00, 0x16]
srcIpAddress = [10, 10, 0, 1]
ST1_ComponentKittingIpAddress = [10, 10, 0, 11]
ST2_FrameCoreAssemblyIpAddress = [10, 10, 0, 12]
ST3_ElectronicsWiringIpAddress = [10, 10, 0, 13]
ST4_CalibrationTestingIpAddress = [10, 10, 0, 14]
ST5_QualityInspectionIpAddress = [10, 10, 0, 15]
ST6_PackagingDispatchIpAddress = [10, 10, 0, 16]

PLC_LineCoordinatorSocketPortNumber0 = 6001
PLC_LineCoordinatorSocketPortNumber1 = 6002
PLC_LineCoordinatorSocketPortNumber2 = 6003
PLC_LineCoordinatorSocketPortNumber3 = 6004
PLC_LineCoordinatorSocketPortNumber4 = 6005
PLC_LineCoordinatorSocketPortNumber5 = 6006

ST1_ComponentKitting0 = 0
ST2_FrameCoreAssembly1 = 1
ST3_ElectronicsWiring2 = 2
ST4_CalibrationTesting3 = 3
ST5_QualityInspection4 = 4
ST6_PackagingDispatch5 = 5


# Start of user custom code region. Please apply edits only within these regions:  Global Variables & Definitions
# PLC coordination state machine for the 6-station line (S1..S6).

STATIONS = ["S1", "S2", "S3", "S4", "S5", "S6"]
RESET_PULSE_TICKS = 3

# Buffer constants
BUF_MAX = 1

# Configuration - Only run S1-S4 for now
ACTIVE_STATIONS = ["S1", "S2", "S3", "S4"]
NUM_STATIONS = 4
# ----------------------------
# Optimization dashboard core (embedded in PLC)
# ----------------------------
OPT_HOST = "0.0.0.0"   # use "0.0.0.0" if you want other PCs to open it
OPT_PORT = 8055

_kpi_lock = threading.Lock()
_kpi_snapshot = {}

_runs_lock = threading.Lock()
_runs = []
_current_run = None

_params_lock = threading.Lock()
_opt_params = {
    "run_enable": True,
    "buf_max": 1,
    "reset_pulse_ticks": 3,
    "w_throughput": 1.0,
    "w_reject": 2.0,
    "w_downtime": 0.5,
    "file_logging": False,
}

# web buttons -> PLC commands (thread-safe)
_web_cmd_lock = threading.Lock()
_web_start_req = False
_web_stop_req = False
_web_reset_req = False

def request_web_start():
    global _web_start_req
    with _web_cmd_lock:
        _web_start_req = True

def request_web_stop():
    global _web_stop_req
    with _web_cmd_lock:
        _web_stop_req = True

def request_web_reset():
    global _web_reset_req
    with _web_cmd_lock:
        _web_reset_req = True

def consume_web_cmds():
    global _web_start_req, _web_stop_req, _web_reset_req
    with _web_cmd_lock:
        s, p, r = _web_start_req, _web_stop_req, _web_reset_req
        _web_start_req = False
        _web_stop_req = False
        _web_reset_req = False
    return s, p, r

def get_params():
    with _params_lock:
        return dict(_opt_params)

def set_params(patch: dict):
    with _params_lock:
        for k, v in patch.items():
            if k in _opt_params:
                _opt_params[k] = v

def _set_kpi_snapshot(snap: dict):
    with _kpi_lock:
        _kpi_snapshot.clear()
        _kpi_snapshot.update(snap)

def _get_kpi_snapshot():
    with _kpi_lock:
        return dict(_kpi_snapshot)

def _score_from_snapshot(snap: dict, params: dict):
    tpm = float(snap.get("throughput_per_min", 0.0))
    reject = float(snap.get("reject", 0.0))
    downtime = float(snap.get("downtime_s", 0.0))
    return (
        float(params.get("w_throughput", 1.0)) * tpm
        - float(params.get("w_reject", 2.0)) * reject
        - float(params.get("w_downtime", 0.5)) * downtime
    )

def _run_start(meta: dict = None):
    global _current_run
    params = get_params()
    r = {
        "run_id": str(uuid.uuid4())[:8],
        "started_at": time.time(),
        "ended_at": None,
        "params": params,
        "meta": meta or {},
        "summary": {},
        "score": None,
    }
    with _runs_lock:
        _current_run = r
    return r

def _run_stop(final_snap: dict):
    global _current_run
    params = get_params()
    with _runs_lock:
        if not _current_run:
            return None
        _current_run["ended_at"] = time.time()
        _current_run["summary"] = {
            "packages_completed": int(final_snap.get("packages_completed", 0)),
            "throughput_per_min": float(final_snap.get("throughput_per_min", 0.0)),
            "accept": int(final_snap.get("accept", 0)),
            "reject": int(final_snap.get("reject", 0)),
            "yield_pct": float(final_snap.get("yield_pct", 0.0)),
            "availability": float(final_snap.get("availability", 0.0)),
            "downtime_s": float(final_snap.get("downtime_s", 0.0)),
            "state": str(final_snap.get("plc_state", "")),
        }
        _current_run["score"] = _score_from_snapshot(final_snap, params)
        _runs.append(_current_run)
        finished = _current_run
        _current_run = None                                             
        return finished

# file logging
KPI_JSON_PATH = "kpi_latest.json"
KPI_CSV_PATH = "kpi_history.csv"
KPI_WRITE_EVERY_TICKS = 2
_kpi_tick_counter = 0
_kpi_csv_header_written = False

def write_kpis_to_files(snapshot: dict):
    global _kpi_tick_counter, _kpi_csv_header_written
    if not bool(get_params().get("file_logging", False)):
        return
    _kpi_tick_counter += 1
    if (_kpi_tick_counter % int(KPI_WRITE_EVERY_TICKS)) != 0:
        return

    tmp = KPI_JSON_PATH + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(snapshot, f, indent=2)
    os.replace(tmp, KPI_JSON_PATH)

    row = {
        "sim_time_s": snapshot.get("sim_time_s", 0.0),
        "plc_state": snapshot.get("plc_state", ""),
        "packages_completed": snapshot.get("packages_completed", 0),
        "accept": snapshot.get("accept", 0),
        "reject": snapshot.get("reject", 0),
        "yield_pct": snapshot.get("yield_pct", 0.0),
        "throughput_per_min": snapshot.get("throughput_per_min", 0.0),
        "availability": snapshot.get("availability", 0.0),
        "downtime_s": snapshot.get("downtime_s", 0.0),
        "fault_any": snapshot.get("fault_any", 0),
    }

    write_header = (not os.path.exists(KPI_CSV_PATH)) or (not _kpi_csv_header_written)
    with open(KPI_CSV_PATH, "a", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=list(row.keys()))
        if write_header:
            w.writeheader()
            _kpi_csv_header_written = True
        w.writerow(row)

# put your existing html string here
HTML_PAGE = r"""<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>VSI Optimization Dashboard</title>
  <style>
    :root{
      --bg0:#0b1020;
      --bg1:#0f1b3a;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.10);
      --txt: rgba(255,255,255,.92);
      --mut: rgba(255,255,255,.60);
      --ok:#39d98a;
      --warn:#f7b955;
      --bad:#ff5d5d;
      --pri:#6ea8ff;
      --pri2:#b56eff;
      --line: rgba(255,255,255,.12);
      --shadow: 0 18px 60px rgba(0,0,0,.35);
      --r: 16px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1200px 900px at 15% 10%, rgba(110,168,255,.22), transparent 55%),
        radial-gradient(900px 700px at 85% 20%, rgba(181,110,255,.18), transparent 55%),
        radial-gradient(1000px 800px at 60% 90%, rgba(57,217,138,.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }

    .wrap{max-width:1200px; margin:0 auto; padding:18px 18px 30px}
    .top{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; flex-wrap:wrap; margin-bottom:14px;
    }

    .title{display:flex; align-items:center; gap:10px;}
    .dot{
      width:10px; height:10px; border-radius:999px;
      background:var(--ok);
      box-shadow: 0 0 0 0 rgba(57,217,138,.55);
      animation: pulse 1.8s infinite;
    }
    .dot.bad{ background:var(--bad); box-shadow: 0 0 0 0 rgba(255,93,93,.55); }
    @keyframes pulse{
      0%{ box-shadow:0 0 0 0 rgba(57,217,138,.50); }
      70%{ box-shadow:0 0 0 14px rgba(57,217,138,0); }
      100%{ box-shadow:0 0 0 0 rgba(57,217,138,0); }
    }

    h1{font-size:18px; margin:0}
    .sub{color:var(--mut); font-size:12px; margin-top:2px}

    .chipRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .chip{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
    }
    .chip b{font-size:12px}
    .chip span{font-size:12px; color:var(--mut)}

    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:10px;
    }

    .card{
      background: var(--card);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      transform: translateZ(0);
    }
    .card::before{
      content:"";
      position:absolute; inset:-2px;
      background: linear-gradient(135deg, rgba(110,168,255,.20), rgba(181,110,255,.12), rgba(57,217,138,.12));
      filter: blur(18px);
      opacity:.55;
      pointer-events:none;
    }
    .card .in{position:relative; padding:12px}

    .kpi{ grid-column: span 4; min-height:106px; }
    @media (max-width: 980px){ .kpi{grid-column: span 6;} }
    @media (max-width: 640px){ .kpi{grid-column: span 12;} }

    .label{color:var(--mut); font-size:12px; display:flex; justify-content:space-between; gap:10px}
    .big{font-size:28px; margin-top:6px; letter-spacing:.2px}
    .tiny{color:var(--mut); font-size:12px; margin-top:4px}

    .spark{
      width:100%; height:34px; display:block;
      margin-top:8px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 12px;
    }

    .bar{
      height:10px; border-radius:999px; background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden; margin-top:10px;
    }
    .bar > i{
      display:block; height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(110,168,255,.95), rgba(181,110,255,.85));
      border-radius:999px;
      transition: width .45s ease;
    }

    .panel{grid-column: span 12;}
    .panel .in{padding:14px}

    .controls{
      display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end;
      margin-top:8px;
    }
    .field{
      display:flex; flex-direction:column; gap:6px;
      min-width:160px;
    }
    .field label{font-size:12px; color:var(--mut)}
    .field input, .field select{
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: var(--txt);
      outline:none;
    }
    .field input:focus, .field select:focus{
      border-color: rgba(110,168,255,.65);
      box-shadow: 0 0 0 3px rgba(110,168,255,.18);
    }

    .btnRow{display:flex; gap:10px; flex-wrap:wrap}
    button{
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--txt);
      cursor:pointer;
      transition: transform .12s ease, background .2s ease;
      user-select:none;
    }
    button:hover{ background: rgba(255,255,255,.12); }
    button:active{ transform: scale(.98); }

    .btnPri{
      background: linear-gradient(135deg, rgba(110,168,255,.28), rgba(181,110,255,.20));
      border-color: rgba(110,168,255,.35);
    }
    .btnGood{
      background: linear-gradient(135deg, rgba(57,217,138,.25), rgba(110,168,255,.10));
      border-color: rgba(57,217,138,.30);
    }
    .btnBad{
      background: linear-gradient(135deg, rgba(255,93,93,.25), rgba(181,110,255,.10));
      border-color: rgba(255,93,93,.30);
    }

    .toast{
      position:fixed; right:16px; bottom:16px;
      padding:10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      color: var(--txt);
      opacity:0;
      transform: translateY(12px);
      transition: opacity .2s ease, transform .2s ease;
      pointer-events:none;
      backdrop-filter: blur(10px);
    }
    .toast.show{opacity:1; transform:translateY(0)}
    .toast small{color:var(--mut)}

    table{width:100%; border-collapse: collapse; margin-top:10px}
    th, td{
      border-bottom: 1px solid rgba(255,255,255,.10);
      padding:10px 8px;
      font-size:12px;
      text-align:left;
      color: var(--txt);
    }
    th{color:var(--mut); font-weight:600}
    tr:hover td{ background: rgba(255,255,255,.04); }

    .badge{
      padding:4px 8px; border-radius:999px; font-size:11px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .badge.good{ border-color: rgba(57,217,138,.35); }
    .badge.bad{ border-color: rgba(255,93,93,.35); }

    pre{
      margin:0;
      padding:12px;
      border-radius: 14px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      overflow:auto;
      color: rgba(255,255,255,.86);
      max-height: 320px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="title">
        <div id="healthDot" class="dot"></div>
        <div>
          <h1>VSI Optimization Dashboard</h1>
          <div class="sub">Live KPIs + decision variables + run comparison</div>
        </div>
      </div>

      <div class="chipRow">
        <div class="chip"><b>State</b><span id="chipState">-</span></div>
        <div class="chip"><b>Batch</b><span id="chipBatch">-</span></div>
        <div class="chip"><b>Recipe</b><span id="chipRecipe">-</span></div>
        <div class="chip"><b>Time</b><span id="chipTime">-</span></div>
      </div>
    </div>

    <div class="grid">
      <div class="card kpi"><div class="in">
        <div class="label"><span>Packages</span><span class="badge" id="bPkg">LIVE</span></div>
        <div class="big" id="kPackages">0</div>
        <div class="bar"><i id="barPkg"></i></div>
        <canvas class="spark" id="cPkg"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Throughput / min</span><span class="badge good" id="bTpm">OK</span></div>
        <div class="big" id="kTpm">0.00</div>
        <div class="tiny">uses packages + sim time</div>
        <canvas class="spark" id="cTpm"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Yield %</span><span class="badge" id="bYield">-</span></div>
        <div class="big" id="kYield">0.0</div>
        <div class="bar"><i id="barYield"></i></div>
        <canvas class="spark" id="cYield"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Availability</span><span class="badge" id="bAvail">-</span></div>
        <div class="big" id="kAvail">0.000</div>
        <div class="bar"><i id="barAvail"></i></div>
        <canvas class="spark" id="cAvail"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Reject</span><span class="badge" id="bReject">-</span></div>
        <div class="big" id="kReject">0</div>
        <div class="tiny">from ST5</div>
        <canvas class="spark" id="cReject"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Fault</span><span class="badge" id="bFault">-</span></div>
        <div class="big" id="kFault">NO</div>
        <div class="tiny">any station fault</div>
        <canvas class="spark" id="cFault"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Bottleneck</span><span class="badge" id="bBneck">-</span></div>
        <div class="big" id="kBneck">-</div>
        <div class="tiny">highest utilization</div>
        <div class="bar"><i id="barBneck"></i></div>
        <canvas class="spark" id="cBneck"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Line idle %</span><span class="badge" id="bIdle">-</span></div>
        <div class="big" id="kIdle">0.0</div>
        <div class="tiny">avg idle across stations</div>
        <div class="bar"><i id="barIdle"></i></div>
        <canvas class="spark" id="cIdle"></canvas>
      </div></div>

      <div class="card kpi"><div class="in">
        <div class="label"><span>Energy / unit</span><span class="badge" id="bEpu">-</span></div>
        <div class="big" id="kEpu">0.000</div>
        <div class="tiny">kWh per finished package</div>
        <div class="bar"><i id="barEpu"></i></div>
        <canvas class="spark" id="cEpu"></canvas>
      </div></div>

      <div class="card panel"><div class="in">
        <div class="label"><span>Decision variables</span><span id="saveHint" class="tiny"></span></div>

        <div class="controls">
          <div class="field">
            <label>run_enable</label>
            <select id="run_enable">
              <option value="true">true</option>
              <option value="false">false</option>
            </select>
          </div>

          <div class="field">
            <label>buf_max</label>
            <input id="buf_max" type="number" step="1" min="0"/>
          </div>

          <div class="field">
            <label>reset_pulse_ticks</label>
            <input id="reset_pulse_ticks" type="number" step="1" min="1"/>
          </div>

          <div class="field">
            <label>w_throughput</label>
            <input id="w_throughput" type="number" step="0.1"/>
          </div>

          <div class="field">
            <label>w_reject</label>
            <input id="w_reject" type="number" step="0.1"/>
          </div>

          <div class="field">
            <label>w_downtime</label>
            <input id="w_downtime" type="number" step="0.1"/>
          </div>

          <div class="field">
            <label>file_logging</label>
            <select id="file_logging">
              <option value="false">false</option>
              <option value="true">true</option>
            </select>
          </div>

          <div class="btnRow">
            <button class="btnPri" onclick="saveParams()">Save Params</button>
            <button class="btnGood" onclick="startRun()">Start Run</button>
            <button class="btnBad" onclick="stopRun()">Stop Run</button>
          </div>
        </div>
      </div></div>

      <div class="card panel"><div class="in">
        <div class="label"><span>Run history</span><span class="tiny">sorted by newest</span></div>
        <div id="runs"></div>
      </div></div>

      <div class="card panel"><div class="in">
        <div class="label"><span>Raw KPI snapshot</span><span class="tiny">/kpi endpoint</span></div>
        <pre id="raw">loading...</pre>
      </div></div>

    </div>
  </div>

  <div class="toast" id="toast"><b id="toastTitle">Saved</b><br/><small id="toastMsg">ok</small></div>

<script>
  async function apiGet(path){
    const r = await fetch(path, {cache:"no-store"});
    return await r.json();
  }
  async function apiPost(path, obj){
    const r = await fetch(path, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(obj||{})
    });
    return await r.json();
  }

  function toast(title, msg){
    const t = document.getElementById("toast");
    document.getElementById("toastTitle").textContent = title;
    document.getElementById("toastMsg").textContent = msg || "";
    t.classList.add("show");
    setTimeout(()=>t.classList.remove("show"), 1400);
  }

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

  const last = {};
  function setNum(id, val, digits){
    const el = document.getElementById(id);
    const prev = (last[id] ?? val);
    const start = performance.now();
    const dur = 260;
    function step(now){
      const t = clamp((now-start)/dur, 0, 1);
      const cur = prev + (val-prev)*t;
      el.textContent = (digits!=null) ? cur.toFixed(digits) : Math.round(cur);
      if(t<1) requestAnimationFrame(step);
      else last[id] = val;
    }
    requestAnimationFrame(step);
  }

  const hist = {
    pkg: [], tpm: [], yield: [], avail: [], reject: [], fault: [],
    bneck: [], idle: [], epu: []
  };
  const MAXN = 120;

  function pushHist(key, v){
    const a = hist[key];
    a.push(v);
    if(a.length > MAXN) a.shift();
  }

  function drawSpark(canvasId, arr){
    const c = document.getElementById(canvasId);
    const ctx = c.getContext("2d");
    const w = c.width = c.clientWidth;
    const h = c.height = c.clientHeight;

    ctx.clearRect(0,0,w,h);

    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.strokeRect(0.5,0.5,w-1,h-1);

    if(!arr.length) return;

    const min = Math.min(...arr);
    const max = Math.max(...arr);
    const span = (max-min) || 1;

    const g = ctx.createLinearGradient(0,0,w,0);
    g.addColorStop(0, "rgba(110,168,255,.95)");
    g.addColorStop(1, "rgba(181,110,255,.90)");

    ctx.lineWidth = 2;
    ctx.strokeStyle = g;
    ctx.beginPath();
    for(let i=0;i<arr.length;i++){
      const x = (i/(arr.length-1)) * (w-10) + 5;
      const y = h - 6 - ((arr[i]-min)/span) * (h-12);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.globalAlpha = 0.12;
    ctx.fillStyle = g;
    ctx.lineTo(w-5, h-6);
    ctx.lineTo(5, h-6);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  async function loadParams(){
    const p = await apiGet("/params");
    document.getElementById("run_enable").value = String(p.run_enable);
    document.getElementById("buf_max").value = p.buf_max;
    document.getElementById("reset_pulse_ticks").value = p.reset_pulse_ticks;
    document.getElementById("w_throughput").value = p.w_throughput;
    document.getElementById("w_reject").value = p.w_reject;
    document.getElementById("w_downtime").value = p.w_downtime;
    document.getElementById("file_logging").value = String(p.file_logging);
  }

  async function saveParams(){
    const patch = {
      run_enable: (document.getElementById("run_enable").value === "true"),
      buf_max: parseInt(document.getElementById("buf_max").value || "1"),
      reset_pulse_ticks: parseInt(document.getElementById("reset_pulse_ticks").value || "3"),
      w_throughput: parseFloat(document.getElementById("w_throughput").value || "1.0"),
      w_reject: parseFloat(document.getElementById("w_reject").value || "2.0"),
      w_downtime: parseFloat(document.getElementById("w_downtime").value || "0.5"),
      file_logging: (document.getElementById("file_logging").value === "true"),
    };
    await apiPost("/params", patch);
    toast("Saved", "params updated");
  }

  async function startRun(){ await apiPost("/run/start", {}); toast("Run", "started"); }
  async function stopRun(){ await apiPost("/run/stop", {}); toast("Run", "stopped"); }

  function renderRuns(data){
    const runs = (data.runs || []).slice().reverse();
    if(!runs.length){
      document.getElementById("runs").innerHTML = "<i style='color:rgba(255,255,255,.6)'>no runs yet</i>";
      return;
    }
    let html = "<table><tr><th>run</th><th>score</th><th>pkg</th><th>tpm</th><th>yield%</th><th>reject</th><th>avail</th><th>state</th></tr>";
    for(const r of runs){
      const s = r.summary || {};
      html += `<tr>
        <td>${r.run_id}</td>
        <td>${(r.score ?? 0).toFixed(2)}</td>
        <td>${s.packages_completed ?? 0}</td>
        <td>${(s.throughput_per_min ?? 0).toFixed(2)}</td>
        <td>${(s.yield_pct ?? 0).toFixed(1)}</td>
        <td>${s.reject ?? 0}</td>
        <td>${(s.availability ?? 0).toFixed(3)}</td>
        <td>${s.state ?? ""}</td>
      </tr>`;
    }
    html += "</table>";
    document.getElementById("runs").innerHTML = html;
  }

  function utilBadgeText(utilPct){
    if(utilPct >= 90) return "HOT";
    if(utilPct >= 75) return "HIGH";
    return "OK";
  }

  async function tick(){
    try{
      const k = await apiGet("/kpi");

      document.getElementById("chipState").textContent = k.plc_state ?? "-";
      document.getElementById("chipBatch").textContent = k.batch_id ?? "-";
      document.getElementById("chipRecipe").textContent = k.recipe_id ?? "-";
      document.getElementById("chipTime").textContent = ((k.sim_time_s ?? 0).toFixed(2) + "s");

      setNum("kPackages", (k.packages_completed ?? 0), null);
      setNum("kTpm", (k.throughput_per_min ?? 0), 2);
      setNum("kYield", (k.yield_pct ?? 0), 1);
      setNum("kAvail", (k.availability ?? 0), 3);
      setNum("kReject", (k.reject ?? 0), null);

      const fault = !!k.fault_any;
      document.getElementById("kFault").textContent = fault ? "YES" : "NO";
      const dot = document.getElementById("healthDot");
      dot.classList.toggle("bad", fault);

      const bStation = (k.bottleneck_station ?? "-");
      const bUtil = (k.bottleneck_utilization ?? 0);
      const bUtilPct = bUtil * 100.0;

      document.getElementById("kBneck").textContent = bStation;
      document.getElementById("bBneck").textContent = utilBadgeText(bUtilPct);
      document.getElementById("barBneck").style.width = clamp(bUtilPct, 0, 100) + "%";

      const idlePct = (k.line_idle_pct ?? 0);
      setNum("kIdle", idlePct, 1);
      document.getElementById("barIdle").style.width = clamp(idlePct, 0, 100) + "%";
      document.getElementById("bIdle").textContent = (idlePct <= 20) ? "GOOD" : "CHECK";

      const epu = (k.energy_kwh_per_unit ?? 0);
      setNum("kEpu", epu, 3);
      const epuPct = clamp((epu / 0.05) * 100.0, 0, 100);
      document.getElementById("barEpu").style.width = epuPct + "%";
      document.getElementById("bEpu").textContent = (epu <= 0.02) ? "GOOD" : "CHECK";

      const pkgPct = clamp((k.packages_completed ?? 0) % 100, 0, 100);
      document.getElementById("barPkg").style.width = pkgPct + "%";
      document.getElementById("barYield").style.width = clamp((k.yield_pct ?? 0), 0, 100) + "%";
      document.getElementById("barAvail").style.width = clamp((k.availability ?? 0)*100, 0, 100) + "%";

      document.getElementById("bFault").textContent = fault ? "FAULT" : "OK";
      document.getElementById("bFault").className = "badge " + (fault ? "bad" : "good");
      document.getElementById("bYield").textContent = ((k.yield_pct ?? 0) >= 95) ? "GOOD" : "CHECK";
      document.getElementById("bAvail").textContent = ((k.availability ?? 0) >= 0.95) ? "GOOD" : "CHECK";

      pushHist("pkg", k.packages_completed ?? 0);
      pushHist("tpm", k.throughput_per_min ?? 0);
      pushHist("yield", k.yield_pct ?? 0);
      pushHist("avail", (k.availability ?? 0) * 100);
      pushHist("reject", k.reject ?? 0);
      pushHist("fault", fault ? 1 : 0);

      pushHist("bneck", bUtilPct);
      pushHist("idle", idlePct);
      pushHist("epu", epu);

      drawSpark("cPkg", hist.pkg);
      drawSpark("cTpm", hist.tpm);
      drawSpark("cYield", hist.yield);
      drawSpark("cAvail", hist.avail);
      drawSpark("cReject", hist.reject);
      drawSpark("cFault", hist.fault);

      drawSpark("cBneck", hist.bneck);
      drawSpark("cIdle", hist.idle);
      drawSpark("cEpu", hist.epu);

      document.getElementById("raw").textContent = JSON.stringify(k, null, 2);

      const r = await apiGet("/runs");
      renderRuns(r);

    }catch(e){
      document.getElementById("raw").textContent = "error: " + e;
    }
  }

  loadParams();
  tick();
  setInterval(tick, 450);
</script>
</body>
</html>
"""


class _OptHandler(BaseHTTPRequestHandler):
    def _send(self, code: int, body: bytes, ctype="application/json; charset=utf-8"):
        self.send_response(code)
        self.send_header("Content-Type", ctype)
        self.send_header("Cache-Control", "no-store")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def _json(self, code: int, obj):
        self._send(code, json.dumps(obj).encode("utf-8"))

    def _read_json(self):
        n = int(self.headers.get("Content-Length", "0"))
        if n <= 0:
            return {}
        raw = self.rfile.read(n).decode("utf-8")
        return json.loads(raw) if raw else {}

    def do_GET(self):
        if self.path.startswith("/kpi"):
            self._json(200, _get_kpi_snapshot()); return
        if self.path.startswith("/params"):
            self._json(200, get_params()); return
        if self.path.startswith("/runs"):
            with _runs_lock:
                data = list(_runs); cur = _current_run
            self._json(200, {"current_run": cur, "runs": data}); return
        if self.path == "/" or self.path.startswith("/index"):
            page = HTML_PAGE if HTML_PAGE is not None else "<h3>HTML_PAGE not set</h3>"
            self._send(200, page.encode("utf-8"), ctype="text/html; charset=utf-8"); return
        self._json(404, {"error":"not found"})

    def do_POST(self):
        if self.path.startswith("/params"):
            patch = self._read_json()
            set_params(patch)
            self._json(200, {"ok": True, "params": get_params()}); return

        if self.path.startswith("/run/start"):
            request_web_start()
            r = _run_start()
            self._json(200, {"ok": True, "current_run": r}); return

        if self.path.startswith("/run/stop"):
            request_web_stop()
            snap = _get_kpi_snapshot()
            finished = _run_stop(snap)
            self._json(200, {"ok": True, "finished": finished}); return

        if self.path.startswith("/run/reset"):
            request_web_reset()
            self._json(200, {"ok": True}); return

        self._json(404, {"error":"not found"})

def start_server():
    try:
        srv = ThreadingHTTPServer((OPT_HOST, OPT_PORT), _OptHandler)
        print(f"Dashboard: http://{OPT_HOST}:{OPT_PORT}")
        srv.serve_forever()
    except Exception as e:
        print("Dashboard server crashed:", repr(e))

def build_kpi_snapshot_from_plc(plc, ms):
    t_s = float(getattr(plc, "_sim_time_s", 0.0))
    t_s = max(0.001, t_s)

    # packages: if S6 exists use it, else use plc.finished (your S1..S4 loop)
    packages = int(getattr(ms, "S6_packages_completed", 0) or getattr(plc, "finished", 0))

    accept = int(getattr(ms, "S5_accept", 0))
    reject = int(getattr(ms, "S5_reject", 0))
    total_q = accept + reject
    yield_pct = (accept / total_q * 100.0) if total_q else 0.0

    tpm = packages / (t_s / 60.0)

    # fault_any from active stations
    fault_any = 1 if any(getattr(ms, f"{st}_fault", 0) for st in ACTIVE_STATIONS) else 0

    # bottleneck: pick busy station (fallback: "-")
    busy_map = {st: int(getattr(ms, f"{st}_busy", 0)) for st in ACTIVE_STATIONS}
    bneck = "-"
    if any(busy_map.values()):
        # pick first busy as "bottleneck" (simple live approximation)
        bneck = [k for k, v in busy_map.items() if v][0]

    # utilization approx: %busy stations (not true time utilization but useful live)
    busy_pct = (sum(busy_map.values()) / max(1, len(ACTIVE_STATIONS)))  # 0..1

    # idle % approx: %not busy
    idle_pct = (1.0 - busy_pct) * 100.0

    downtime_s = float(getattr(ms, "S6_downtime_s", 0.0))
    availability = float(getattr(ms, "S6_availability", 0.0))

    return {
        "sim_time_s": t_s,
        "plc_state": str(getattr(plc, "_state", "")),
        "batch_id": int(getattr(plc, "_batch_id", 0)),
        "recipe_id": int(getattr(plc, "_recipe_id", 0)),

        "packages_completed": packages,
        "throughput_per_min": float(tpm),

        "accept": accept,
        "reject": reject,
        "yield_pct": float(yield_pct),

        "buffers": dict(getattr(plc, "_buffers", {})),

        "bottleneck_station": bneck,
        "bottleneck_utilization": float(busy_pct),  # 0..1

        "line_idle_pct": float(idle_pct),
        "energy_kwh_per_unit": 0.0,  # set later if you add energy signals

        "downtime_s": float(downtime_s),
        "availability": float(availability),

        "fault_any": int(fault_any),
    }




def _set_context(ms, st, batch_id, recipe_id):
    setattr(ms, f"{st}_batch_id", int(batch_id))
    setattr(ms, f"{st}_recipe_id", int(recipe_id))


def _get(ms, st, field):
    return getattr(ms, f"{st}_{field}")


def _set_cmd(ms, st, start=None, stop=None, reset=None):
    if start is not None:
        setattr(ms, f"{st}_cmd_start", 1 if start else 0)
    if stop is not None:
        setattr(ms, f"{st}_cmd_stop", 1 if stop else 0)
    if reset is not None:
        setattr(ms, f"{st}_cmd_reset", 1 if reset else 0)


def _stop_station(ms, st):
    _set_cmd(ms, st, start=0, stop=1, reset=0)


def _start_station(ms, st):
    _set_cmd(ms, st, start=1, stop=0, reset=0)


def _reset_station(ms, st):
    _set_cmd(ms, st, start=0, stop=1, reset=1)


def _stop_all(ms):
    for st in STATIONS:
        _stop_station(ms, st)


def _start_all(ms):
    for st in STATIONS:
        _start_station(ms, st)


def _reset_all(ms):
    for st in STATIONS:
        _reset_station(ms, st)


def _any_fault(ms):
    # Only check active stations for faults
    return any(_get(ms, st, "fault") for st in ACTIVE_STATIONS)


def _all_stations_connected_and_ready(ms, station_handles):
    """Check if all active stations are connected and ready"""
    for st in ACTIVE_STATIONS:
        # Check connection
        if station_handles[st] == 0:
            return False, f"{st} not connected"
        
        # Check ready state
        ready = _get(ms, st, "ready")
        busy = _get(ms, st, "busy")
        fault = _get(ms, st, "fault")
        
        if not ready or busy or fault:
            return False, f"{st} not ready (ready={ready}, busy={busy}, fault={fault})"
    
    return True, "All stations ready"
# End of user custom code region.


class PLC_LineCoordinator:

    def __init__(self, args):
        self.componentId = 0
        self.localHost = args.server_url
        self.domain = args.domain
        self.portNum = 50101

        self.simulationStep = 0
        self.stopRequested = False
        self.totalSimulationTime = 0

        self.receivedNumberOfBytes = 0
        self.receivedPayload = []

        self.numberOfPorts = 6
        self.clientPortNum = [0] * self.numberOfPorts
        self.receivedDestPortNumber = 0
        self.receivedSrcPortNumber = 0
        self.expectedNumberOfBytes = 0
        self.mySignals = MySignals()

        # Start of user custom code region. Please apply edits only within these regions:  Constructor
        # coordinator internal state
        self._batch_id = 1
        self._recipe_id = 1

        # Master run control
        self._run_latched = False
        self._prev_op_cmd_start = 0
        self._op_cmd_start = 0  # Simulated operator command (will set to 1 after delay)
        self._op_cmd_stop = 0
        self._op_cmd_reset = 0

        # State machine
        self._state = "RESET_ALL"
        self._reset_ticks = 0

        # Previous done states for edge detection
        self._prev_done = {
            "S1": False, "S2": False, "S3": False, 
            "S4": False, "S5": False, "S6": False
        }
        
        # DONE LATCHES (Critical fix)
        self._done_latched = {
            "S1": False, "S2": False, "S3": False,
            "S4": False, "S5": False, "S6": False
        }
        
        # Start pulse sent flags (ensure one-shot)
        self._start_sent = {
            "S1": False, "S2": False, "S3": False,
            "S4": False, "S5": False, "S6": False
        }

        # pipeline buffers
        self._buffers = {
            "S1_to_S2": 0,
            "S2_to_S3": 0,
            "S3_to_S4": 0,
            "S4_to_S5": 0,
            "S5_to_S6": 0,
        }
        
        self.finished = 0  # Completed packages from S6

        # KPI totals for ST5
        self._s5_accept_total = 0
        self._s5_reject_total = 0

        # Store actual connection handles for sending commands
        self.station_handles = {
            "S1": 0,
            "S2": 0,
            "S3": 0,
            "S4": 0,
            "S5": 0,
            "S6": 0
        }
        
        # Debug counters and timers
        self._scan_count = 0
        self._sim_time_s = 0.0
        
        # Auto-start timer - simulate operator pressing start after 2 seconds
        self._auto_start_time = 2.0
        self._auto_start_done = False
        # End of user custom code region.


    def mainThread(self):
        dSession = vsiCommonPythonApi.connectToServer(self.localHost, self.domain, self.portNum, self.componentId)
        vsiEthernetPythonGateway.initialize(dSession, self.componentId, bytes(srcMacAddress), bytes(srcIpAddress))
        try:
            vsiCommonPythonApi.waitForReset()

            # Start of user custom code region. Please apply edits only within these regions:  After Reset
            # Initialize pipeline controller state
            self._batch_id = 1
            self._recipe_id = 1

            # Master run control
            self._run_latched = False
            self._prev_op_cmd_start = 0
            self._op_cmd_start = 0
            self._op_cmd_stop = 0
            self._op_cmd_reset = 0

            # State machine
            self._state = "RESET_ALL"
            self._reset_ticks = 0

            # Virtual buffers (tokens) between stations
            self._buffers = {
                "S1_to_S2": 0,
                "S2_to_S3": 0,
                "S3_to_S4": 0,
                "S4_to_S5": 0,
                "S5_to_S6": 0,
            }
            self.finished = 0

            # Edge trackers
            self._prev_done = {st: False for st in STATIONS}
            self._done_latched = {st: False for st in STATIONS}
            self._start_sent = {st: False for st in STATIONS}
            self._scan_count = 0
            self._sim_time_s = 0.0
            
            # Auto-start control
            self._auto_start_done = False

            # KPI counters
            self._s5_accept_total = 0
            self._s5_reject_total = 0

            # Pulse reset on all stations at sim start
            _reset_all(self.mySignals)

            # Initial context
            for st in STATIONS:
                _set_context(self.mySignals, st, self._batch_id, self._recipe_id)

            # Reset station handles (learned from RX packets)
            for st in STATIONS:
                self.station_handles[st] = 0
                
            print("PLC: Initialized with state machine, ready for S1->S2->S3->S4 sequencing")
            print(f"PLC: Active stations: {ACTIVE_STATIONS}")
            # start dashboard web server once
            if not hasattr(self, "_dash_thread"):
                self._dash_thread = threading.Thread(target=start_server, daemon=True)
                self._dash_thread.start()

            # End of user custom code region.
            self.updateInternalVariables()

            if(vsiCommonPythonApi.isStopRequested()):
                raise Exception("stopRequested")
            self.establishTcpUdpConnection()
            nextExpectedTime = vsiCommonPythonApi.getSimulationTimeInNs()
            while(vsiCommonPythonApi.getSimulationTimeInNs() < self.totalSimulationTime):


                self.updateInternalVariables()

                if(vsiCommonPythonApi.isStopRequested()):
                    raise Exception("stopRequested")

                if(vsiEthernetPythonGateway.isTerminationOnGoing()):
                    print("Termination is on going")
                    break

                if(vsiEthernetPythonGateway.isTerminated()):
                    print("Application terminated")
                    break

                receivedData = vsiEthernetPythonGateway.recvEthernetPacket(self.clientPortNum[ST1_ComponentKitting0])
                if(receivedData[3] != 0):
                    self.decapsulateReceivedData(receivedData)

                receivedData = vsiEthernetPythonGateway.recvEthernetPacket(self.clientPortNum[ST2_FrameCoreAssembly1])
                if(receivedData[3] != 0):
                    self.decapsulateReceivedData(receivedData)

                receivedData = vsiEthernetPythonGateway.recvEthernetPacket(self.clientPortNum[ST3_ElectronicsWiring2])
                if(receivedData[3] != 0):
                    self.decapsulateReceivedData(receivedData)

                receivedData = vsiEthernetPythonGateway.recvEthernetPacket(self.clientPortNum[ST4_CalibrationTesting3])
                if(receivedData[3] != 0):
                    self.decapsulateReceivedData(receivedData)

                receivedData = vsiEthernetPythonGateway.recvEthernetPacket(self.clientPortNum[ST5_QualityInspection4])
                if(receivedData[3] != 0):
                    self.decapsulateReceivedData(receivedData)

                receivedData = vsiEthernetPythonGateway.recvEthernetPacket(self.clientPortNum[ST6_PackagingDispatch5])
                if(receivedData[3] != 0):
                    self.decapsulateReceivedData(receivedData)

                # Start of user custom code region. Please apply edits only within these regions:  Before sending the packet
                ms = self.mySignals
                self._scan_count += 1
                self._sim_time_s = vsiCommonPythonApi.getSimulationTimeInNs() / 1e9

                # ---- SIMULATE OPERATOR COMMANDS (Auto-start after delay) ----
                # After 2 seconds, simulate operator pressing START
                if not self._auto_start_done and self._sim_time_s > self._auto_start_time:
                    print(f"PLC: Auto-start triggered at {self._sim_time_s:.1f}s")
                    self._op_cmd_start = 1
                    self._auto_start_done = True
                else:
                    self._op_cmd_start = 0

                # ---- MASTER RUN LATCH LOGIC ----
                # Rising edge detection for operator start command
                op_start_edge = (self._op_cmd_start == 1 and self._prev_op_cmd_start == 0)
                
                if op_start_edge:
                    print("PLC: Operator START command (rising edge) -> setting run_latched=True")
                    self._run_latched = True
                
                # Stop command clears run latch
                if self._op_cmd_stop:
                    print("PLC: Operator STOP command -> clearing run_latched")
                    self._run_latched = False
                
                # Reset command clears everything
                if self._op_cmd_reset:
                    print("PLC: Operator RESET command -> full reset")
                    self._run_latched = False
                    self._state = "RESET_ALL"
                    self._reset_ticks = 0
                
                self._prev_op_cmd_start = self._op_cmd_start

                # 1) PRINT PLC STATE EVERY SCAN
                print(f"\n=== PLC SCAN {self._scan_count} ===")
                print(f"state={self._state} run_latched={int(self._run_latched)} op_cmd_start={self._op_cmd_start}")
                
                # Print station status
                for st in ACTIVE_STATIONS:
                    conn = 1 if self.station_handles[st] != 0 else 0
                    ready = _get(ms, st, "ready")
                    busy = _get(ms, st, "busy")
                    done = _get(ms, st, "done")
                    cmd_out_start = _get(ms, st, "cmd_start")
                    print(f"{st}: conn={conn} ready={ready} busy={busy} done={done} cmd_out_start={cmd_out_start}")

                # Keep station context updated
                for st in STATIONS:
                    _set_context(ms, st, self._batch_id, self._recipe_id)

                # ---- FAULT handling ----
                if _any_fault(ms) and self._state != "FAULT_RESET":
                    print("PLC: Fault detected, entering FAULT_RESET state")
                    self._state = "FAULT_RESET"
                    self._reset_ticks = 0
                    self._run_latched = False  # Stop on fault

                # ---- RESET_ALL / FAULT_RESET ----
                if self._state in ("RESET_ALL", "FAULT_RESET"):
                    _reset_all(ms)
                    self._reset_ticks += 1
                    print(f"PLC: In {self._state} state, tick {self._reset_ticks}/{RESET_PULSE_TICKS}")

                    # Clear pipeline state while resetting
                    for k in self._buffers:
                        self._buffers[k] = 0
                    self.finished = 0
                    self._done_latched = {st: False for st in STATIONS}
                    self._prev_done = {st: False for st in STATIONS}
                    self._start_sent = {st: False for st in STATIONS}

                    if self._reset_ticks >= RESET_PULSE_TICKS:
                        # Deassert reset/stop when entering RUN
                        for st in STATIONS:
                            _set_cmd(ms, st, start=0, stop=0, reset=0)
                        self._state = "WAIT_ALL_READY"
                        print("PLC: Entering WAIT_ALL_READY state")

                # ---- WAIT_ALL_READY: Wait for all ACTIVE stations to be ready ----
                elif self._state == "WAIT_ALL_READY":
                    # Only proceed if run is latched
                    if not self._run_latched:
                        print("PLC: Waiting for run latch...")
                        # Clear all commands while waiting
                        for st in STATIONS:
                            _set_cmd(ms, st, start=0, stop=0, reset=0)
                    else:
                        # Check if all ACTIVE stations are connected and ready
                        all_ready, reason = _all_stations_connected_and_ready(ms, self.station_handles)
                        
                        if all_ready:
                            print("PLC: All active stations ready, moving to START_S1")
                            self._state = "START_S1"
                            # Clear all commands before starting
                            for st in STATIONS:
                                _set_cmd(ms, st, start=0, stop=0, reset=0)
                        else:
                            print(f"PLC: Waiting for stations to be ready... {reason}")

                # ---- START_S1: Send ONE-SCAN start pulse to S1 ----
                elif self._state == "START_S1":
                    # Only proceed if run is latched
                    if not self._run_latched:
                        print("PLC: Run not latched, going back to WAIT_ALL_READY")
                        self._state = "WAIT_ALL_READY"
                        continue
                    
                    # Clear all start commands first
                    for st in STATIONS:
                        _set_cmd(ms, st, start=0, stop=0, reset=0)
                    
                    # Check if S1 is ready to start
                    s1_ready = _get(ms, "S1", "ready")
                    s1_busy = _get(ms, "S1", "busy")
                    s1_fault = _get(ms, "S1", "fault")
                    
                    print(f"  START_S1: ready={s1_ready}, busy={s1_busy}, fault={s1_fault}, start_sent={self._start_sent['S1']}")
                    
                    if (s1_ready and not s1_busy and not s1_fault):
                        if not self._start_sent["S1"]:
                            print("PLC: Sending ONE-SCAN START pulse -> S1")
                            _set_cmd(ms, "S1", start=1, stop=0, reset=0)
                            self._start_sent["S1"] = True
                            # Set a flag to clear start on next scan
                            self._clear_s1_start_next_scan = True
                        elif hasattr(self, '_clear_s1_start_next_scan') and self._clear_s1_start_next_scan:
                            # Clear the start pulse after one scan
                            print("PLC: Clearing S1 start pulse (one-shot)")
                            _set_cmd(ms, "S1", start=0, stop=0, reset=0)
                            delattr(self, '_clear_s1_start_next_scan')
                            self._state = "WAIT_S1_DONE"
                    else:
                        print(f"PLC: S1 not ready to start")

                # ---- WAIT_S1_DONE: Wait for S1 to complete ----
                elif self._state == "WAIT_S1_DONE":
                    # Clear S1 start command (should already be cleared)
                    _set_cmd(ms, "S1", start=0, stop=0, reset=0)
                    
                    # Check if S1 has become busy (acknowledged the start)
                    s1_busy = _get(ms, "S1", "busy")
                    if s1_busy and not self._done_latched["S1"]:
                        print("PLC: S1 busy ACK received")
                        self._done_latched["S1"] = True
                    
                    # Latch S1 done (rising edge detection)
                    s1_done = _get(ms, "S1", "done")
                    s1_done_edge = (s1_done and not self._prev_done["S1"])
                    
                    if s1_done_edge:
                        print("PLC: S1 done rising edge detected -> latching")
                        self._done_latched["S1"] = True
                    
                    # If S1 done is latched and S1 is no longer busy, advance
                    s1_ready = _get(ms, "S1", "ready")
                    
                    if (self._done_latched["S1"] and not s1_busy and s1_ready):
                        print("PLC: S1 cycle complete -> advancing to START_S2")
                        self._done_latched["S1"] = False
                        self._start_sent["S1"] = False
                        self._state = "START_S2"
                        
                        # Buffer S1->S2
                        self._buffers["S1_to_S2"] = min(self._buffers["S1_to_S2"] + 1, BUF_MAX)
                        print(f"PLC: Incremented S1_to_S2 buffer to {self._buffers['S1_to_S2']}")
                    else:
                        print(f"  WAIT_S1_DONE: done_latched={self._done_latched['S1']}, busy={s1_busy}, ready={s1_ready}, done={s1_done}")

                # ---- START_S2: Send ONE-SCAN start pulse to S2 ----
                elif self._state == "START_S2":
                    # Clear all start commands
                    for st in STATIONS:
                        _set_cmd(ms, st, start=0, stop=0, reset=0)
                    
                    # Check if S2 is ready and has work from S1
                    s2_ready = _get(ms, "S2", "ready")
                    s2_busy = _get(ms, "S2", "busy")
                    s2_fault = _get(ms, "S2", "fault")
                    
                    print(f"  START_S2: ready={s2_ready}, busy={s2_busy}, fault={s2_fault}, buffer={self._buffers['S1_to_S2']}, start_sent={self._start_sent['S2']}")
                    
                    if (s2_ready and not s2_busy and not s2_fault and self._buffers["S1_to_S2"] > 0):
                        if not self._start_sent["S2"]:
                            print("PLC: Sending ONE-SCAN START pulse -> S2")
                            _set_cmd(ms, "S2", start=1, stop=0, reset=0)
                            self._start_sent["S2"] = True
                            # Set a flag to clear start on next scan
                            self._clear_s2_start_next_scan = True
                        elif hasattr(self, '_clear_s2_start_next_scan') and self._clear_s2_start_next_scan:
                            # Clear the start pulse after one scan
                            print("PLC: Clearing S2 start pulse (one-shot)")
                            _set_cmd(ms, "S2", start=0, stop=0, reset=0)
                            delattr(self, '_clear_s2_start_next_scan')
                            self._state = "WAIT_S2_DONE"
                            
                            # Consume buffer
                            self._buffers["S1_to_S2"] = max(0, self._buffers["S1_to_S2"] - 1)
                            print(f"PLC: Consumed S1_to_S2 buffer, now {self._buffers['S1_to_S2']}")
                    else:
                        print(f"PLC: S2 not ready to start")

                # ---- WAIT_S2_DONE: Wait for S2 to complete ----
                elif self._state == "WAIT_S2_DONE":
                    # Clear S2 start command
                    _set_cmd(ms, "S2", start=0, stop=0, reset=0)
                    
                    # Check if S2 has become busy (acknowledged the start)
                    s2_busy = _get(ms, "S2", "busy")
                    if s2_busy and not self._done_latched["S2"]:
                        print("PLC: S2 busy ACK received")
                        self._done_latched["S2"] = True
                    
                    # Latch S2 done (rising edge detection)
                    s2_done = _get(ms, "S2", "done")
                    s2_done_edge = (s2_done and not self._prev_done["S2"])
                    
                    if s2_done_edge:
                        print("PLC: S2 done rising edge detected -> latching")
                        self._done_latched["S2"] = True
                    
                    # If S2 done is latched and S2 is no longer busy, advance
                    s2_ready = _get(ms, "S2", "ready")
                    
                    if (self._done_latched["S2"] and not s2_busy and s2_ready):
                        print("PLC: S2 cycle complete -> advancing to START_S3")
                        self._done_latched["S2"] = False
                        self._start_sent["S2"] = False
                        self._state = "START_S3"
                        
                        # Buffer S2->S3
                        self._buffers["S2_to_S3"] = min(self._buffers["S2_to_S3"] + 1, BUF_MAX)
                        print(f"PLC: Incremented S2_to_S3 buffer to {self._buffers['S2_to_S3']}")
                    else:
                        print(f"  WAIT_S2_DONE: done_latched={self._done_latched['S2']}, busy={s2_busy}, ready={s2_ready}, done={s2_done}")

                # ---- START_S3: Send ONE-SCAN start pulse to S3 ----
                elif self._state == "START_S3":
                    # Clear all start commands
                    for st in STATIONS:
                        _set_cmd(ms, st, start=0, stop=0, reset=0)
                    
                    # Check if S3 is ready and has work from S2
                    s3_ready = _get(ms, "S3", "ready")
                    s3_busy = _get(ms, "S3", "busy")
                    s3_fault = _get(ms, "S3", "fault")
                    
                    print(f"  START_S3: ready={s3_ready}, busy={s3_busy}, fault={s3_fault}, buffer={self._buffers['S2_to_S3']}, start_sent={self._start_sent['S3']}")
                    
                    if (s3_ready and not s3_busy and not s3_fault and self._buffers["S2_to_S3"] > 0):
                        if not self._start_sent["S3"]:
                            print("PLC: Sending ONE-SCAN START pulse -> S3")
                            _set_cmd(ms, "S3", start=1, stop=0, reset=0)
                            self._start_sent["S3"] = True
                            # Set a flag to clear start on next scan
                            self._clear_s3_start_next_scan = True
                        elif hasattr(self, '_clear_s3_start_next_scan') and self._clear_s3_start_next_scan:
                            # Clear the start pulse after one scan
                            print("PLC: Clearing S3 start pulse (one-shot)")
                            _set_cmd(ms, "S3", start=0, stop=0, reset=0)
                            delattr(self, '_clear_s3_start_next_scan')
                            self._state = "WAIT_S3_DONE"
                            
                            # Consume buffer
                            self._buffers["S2_to_S3"] = max(0, self._buffers["S2_to_S3"] - 1)
                            print(f"PLC: Consumed S2_to_S3 buffer, now {self._buffers['S2_to_S3']}")
                    else:
                        print(f"PLC: S3 not ready to start")

                # ---- WAIT_S3_DONE: Wait for S3 to complete ----
                elif self._state == "WAIT_S3_DONE":
                    # Clear S3 start command
                    _set_cmd(ms, "S3", start=0, stop=0, reset=0)
                    
                    # Check if S3 has become busy (acknowledged the start)
                    s3_busy = _get(ms, "S3", "busy")
                    if s3_busy and not self._done_latched["S3"]:
                        print("PLC: S3 busy ACK received")
                        self._done_latched["S3"] = True
                    
                    # Latch S3 done (rising edge detection)
                    s3_done = _get(ms, "S3", "done")
                    s3_done_edge = (s3_done and not self._prev_done["S3"])
                    
                    if s3_done_edge:
                        print("PLC: S3 done rising edge detected -> latching")
                        self._done_latched["S3"] = True
                    
                    # If S3 done is latched and S3 is no longer busy, advance
                    s3_ready = _get(ms, "S3", "ready")
                    
                    if (self._done_latched["S3"] and not s3_busy and s3_ready):
                        print("PLC: S3 cycle complete -> advancing to START_S4")
                        self._done_latched["S3"] = False
                        self._start_sent["S3"] = False
                        self._state = "START_S4"
                        
                        # Buffer S3->S4
                        self._buffers["S3_to_S4"] = min(self._buffers["S3_to_S4"] + 1, BUF_MAX)
                        print(f"PLC: Incremented S3_to_S4 buffer to {self._buffers['S3_to_S4']}")
                    else:
                        print(f"  WAIT_S3_DONE: done_latched={self._done_latched['S3']}, busy={s3_busy}, ready={s3_ready}, done={s3_done}")

                # ---- START_S4: Send ONE-SCAN start pulse to S4 ----
                elif self._state == "START_S4":
                    # Clear all start commands
                    for st in STATIONS:
                        _set_cmd(ms, st, start=0, stop=0, reset=0)
                    
                    # Check if S4 is ready and has work from S3
                    s4_ready = _get(ms, "S4", "ready")
                    s4_busy = _get(ms, "S4", "busy")
                    s4_fault = _get(ms, "S4", "fault")
                    
                    print(f"  START_S4: ready={s4_ready}, busy={s4_busy}, fault={s4_fault}, buffer={self._buffers['S3_to_S4']}, start_sent={self._start_sent['S4']}")
                    
                    if (s4_ready and not s4_busy and not s4_fault and self._buffers["S3_to_S4"] > 0):
                        if not self._start_sent["S4"]:
                            print("PLC: Sending ONE-SCAN START pulse -> S4")
                            _set_cmd(ms, "S4", start=1, stop=0, reset=0)
                            self._start_sent["S4"] = True
                            # Set a flag to clear start on next scan
                            self._clear_s4_start_next_scan = True
                        elif hasattr(self, '_clear_s4_start_next_scan') and self._clear_s4_start_next_scan:
                            # Clear the start pulse after one scan
                            print("PLC: Clearing S4 start pulse (one-shot)")
                            _set_cmd(ms, "S4", start=0, stop=0, reset=0)
                            delattr(self, '_clear_s4_start_next_scan')
                            self._state = "WAIT_S4_DONE"
                            
                            # Consume buffer
                            self._buffers["S3_to_S4"] = max(0, self._buffers["S3_to_S4"] - 1)
                            print(f"PLC: Consumed S3_to_S4 buffer, now {self._buffers['S3_to_S4']}")
                    else:
                        print(f"PLC: S4 not ready to start")

                # ---- WAIT_S4_DONE: Wait for S4 to complete ----
                elif self._state == "WAIT_S4_DONE":
                    # Clear S4 start command
                    _set_cmd(ms, "S4", start=0, stop=0, reset=0)
                    
                    # Check if S4 has become busy (acknowledged the start)
                    s4_busy = _get(ms, "S4", "busy")
                    if s4_busy and not self._done_latched["S4"]:
                        print("PLC: S4 busy ACK received")
                        self._done_latched["S4"] = True
                    
                    # Latch S4 done (rising edge detection)
                    s4_done = _get(ms, "S4", "done")
                    s4_done_edge = (s4_done and not self._prev_done["S4"])
                    
                    if s4_done_edge:
                        print("PLC: S4 done rising edge detected -> latching")
                        self._done_latched["S4"] = True
                    
                    # If S4 done is latched and S4 is no longer busy, complete cycle
                    s4_ready = _get(ms, "S4", "ready")
                    
                    if (self._done_latched["S4"] and not s4_busy and s4_ready):
                        print("PLC: S4 cycle complete -> batch finished, restarting")
                        self._done_latched["S4"] = False
                        self._start_sent["S4"] = False
                        
                        # Buffer S4->S5 (for future)
                        self._buffers["S4_to_S5"] = min(self._buffers["S4_to_S5"] + 1, BUF_MAX)
                        
                        # Increment batch and go back to start
                        self._batch_id += 1
                        self.finished += 1
                        print(f"PLC: Batch {self._batch_id-1} complete, starting batch {self._batch_id}")
                        
                        # Go back to START_S1 for next unit
                        self._state = "START_S1"
                    else:
                        print(f"  WAIT_S4_DONE: done_latched={self._done_latched['S4']}, busy={s4_busy}, ready={s4_ready}, done={s4_done}")
                
                # Update DONE LATCHES (safety catch - should already be done above)
                for st in ACTIVE_STATIONS:
                    if _get(ms, st, "done"):
                        if not self._done_latched[st]:
                            print(f"PLC: Safety latch for {st} done")
                            self._done_latched[st] = True
                
                # Update previous states for edge detection
                for st in STATIONS:
                    self._prev_done[st] = (_get(ms, st, "done") == 1)

                # 2) PRINT WHAT PLC IS TRANSMITTING
                print("TX commands:")
                for st in ACTIVE_STATIONS:
                    cmd_start = _get(ms, st, "cmd_start")
                    cmd_reset = _get(ms, st, "cmd_reset")
                    cmd_stop = _get(ms, st, "cmd_stop")
                    print(f"  TX {st} start={cmd_start} reset={cmd_reset} stop={cmd_stop}")
                                # publish KPI snapshot for dashboard
                snap = build_kpi_snapshot_from_plc(self, ms)
                _set_kpi_snapshot(snap)
                write_kpis_to_files(snap)

                # End of user custom code region.
                #Send ethernet packet to ST1_ComponentKitting
                self.sendEthernetPacketToST1_ComponentKitting()

                #Send ethernet packet to ST2_FrameCoreAssembly
                self.sendEthernetPacketToST2_FrameCoreAssembly()

                #Send ethernet packet to ST3_ElectronicsWiring
                self.sendEthernetPacketToST3_ElectronicsWiring()

                #Send ethernet packet to ST4_CalibrationTesting
                self.sendEthernetPacketToST4_CalibrationTesting()

                #Send ethernet packet to ST5_QualityInspection
                self.sendEthernetPacketToST5_QualityInspection()

                #Send ethernet packet to ST6_PackagingDispatch
                self.sendEthernetPacketToST6_PackagingDispatch()

                # Start of user custom code region. Please apply edits only within these regions:  After sending the packet

                # End of user custom code region. Please don't edit beyond this point.

                print("\n+=PLC_LineCoordinator+=")
                print("  VSI time:", end = " ")
                print(vsiCommonPythonApi.getSimulationTimeInNs(), end = " ")
                print("ns")
                print("  Inputs:")
                print("\tS1_ready =", end = " ")
                print(self.mySignals.S1_ready)
                print("\tS1_busy =", end = " ")
                print(self.mySignals.S1_busy)
                print("\tS1_fault =", end = " ")
                print(self.mySignals.S1_fault)
                print("\tS1_done =", end = " ")
                print(self.mySignals.S1_done)
                print("\tS1_cycle_time_ms =", end = " ")
                print(self.mySignals.S1_cycle_time_ms)
                print("\tS1_inventory_ok =", end = " ")
                print(self.mySignals.S1_inventory_ok)
                print("\tS1_any_arm_failed =", end = " ")
                print(self.mySignals.S1_any_arm_failed)
                print("\tS2_ready =", end = " ")
                print(self.mySignals.S2_ready)
                print("\tS2_busy =", end = " ")
                print(self.mySignals.S2_busy)
                print("\tS2_fault =", end = " ")
                print(self.mySignals.S2_fault)
                print("\tS2_done =", end = " ")
                print(self.mySignals.S2_done)
                print("\tS2_cycle_time_ms =", end = " ")
                print(self.mySignals.S2_cycle_time_ms)
                print("\tS2_completed =", end = " ")
                print(self.mySignals.S2_completed)
                print("\tS2_scrapped =", end = " ")
                print(self.mySignals.S2_scrapped)
                print("\tS2_reworks =", end = " ")
                print(self.mySignals.S2_reworks)
                print("\tS2_cycle_time_avg_s =", end = " ")
                print(self.mySignals.S2_cycle_time_avg_s)
                print("\tS3_ready =", end = " ")
                print(self.mySignals.S3_ready)
                print("\tS3_busy =", end = " ")
                print(self.mySignals.S3_busy)
                print("\tS3_fault =", end = " ")
                print(self.mySignals.S3_fault)
                print("\tS3_done =", end = " ")
                print(self.mySignals.S3_done)
                print("\tS3_cycle_time_ms =", end = " ")
                print(self.mySignals.S3_cycle_time_ms)
                print("\tS3_strain_relief_ok =", end = " ")
                print(self.mySignals.S3_strain_relief_ok)
                print("\tS3_continuity_ok =", end = " ")
                print(self.mySignals.S3_continuity_ok)
                print("\tS4_ready =", end = " ")
                print(self.mySignals.S4_ready)
                print("\tS4_busy =", end = " ")
                print(self.mySignals.S4_busy)
                print("\tS4_fault =", end = " ")
                print(self.mySignals.S4_fault)
                print("\tS4_done =", end = " ")
                print(self.mySignals.S4_done)
                print("\tS4_cycle_time_ms =", end = " ")
                print(self.mySignals.S4_cycle_time_ms)
                print("\tS4_total =", end = " ")
                print(self.mySignals.S4_total)
                print("\tS4_completed =", end = " ")
                print(self.mySignals.S4_completed)
                print("\tS5_ready =", end = " ")
                print(self.mySignals.S5_ready)
                print("\tS5_busy =", end = " ")
                print(self.mySignals.S5_busy)
                print("\tS5_fault =", end = " ")
                print(self.mySignals.S5_fault)
                print("\tS5_done =", end = " ")
                print(self.mySignals.S5_done)
                print("\tS5_cycle_time_ms =", end = " ")
                print(self.mySignals.S5_cycle_time_ms)
                print("\tS5_accept =", end = " ")
                print(self.mySignals.S5_accept)
                print("\tS5_reject =", end = " ")
                print(self.mySignals.S5_reject)
                print("\tS5_last_accept =", end = " ")
                print(self.mySignals.S5_last_accept)
                print("\tS6_ready =", end = " ")
                print(self.mySignals.S6_ready)
                print("\tS6_busy =", end = " ")
                print(self.mySignals.S6_busy)
                print("\tS6_fault =", end = " ")
                print(self.mySignals.S6_fault)
                print("\tS6_done =", end = " ")
                print(self.mySignals.S6_done)
                print("\tS6_cycle_time_ms =", end = " ")
                print(self.mySignals.S6_cycle_time_ms)
                print("\tS6_packages_completed =", end = " ")
                print(self.mySignals.S6_packages_completed)
                print("\tS6_arm_cycles =", end = " ")
                print(self.mySignals.S6_arm_cycles)
                print("\tS6_total_repairs =", end = " ")
                print(self.mySignals.S6_total_repairs)
                print("\tS6_operational_time_s =", end = " ")
                print(self.mySignals.S6_operational_time_s)
                print("\tS6_downtime_s =", end = " ")
                print(self.mySignals.S6_downtime_s)
                print("\tS6_availability =", end = " ")
                print(self.mySignals.S6_availability)
                print("  Outputs:")
                print("\tS1_cmd_start =", end = " ")
                print(self.mySignals.S1_cmd_start)
                print("\tS1_cmd_stop =", end = " ")
                print(self.mySignals.S1_cmd_stop)
                print("\tS1_cmd_reset =", end = " ")
                print(self.mySignals.S1_cmd_reset)
                print("\tS1_batch_id =", end = " ")
                print(self.mySignals.S1_batch_id)
                print("\tS1_recipe_id =", end = " ")
                print(self.mySignals.S1_recipe_id)
                print("\tS2_cmd_start =", end = " ")
                print(self.mySignals.S2_cmd_start)
                print("\tS2_cmd_stop =", end = " ")
                print(self.mySignals.S2_cmd_stop)
                print("\tS2_cmd_reset =", end = " ")
                print(self.mySignals.S2_cmd_reset)
                print("\tS2_batch_id =", end = " ")
                print(self.mySignals.S2_batch_id)
                print("\tS2_recipe_id =", end = " ")
                print(self.mySignals.S2_recipe_id)
                print("\tS3_cmd_start =", end = " ")
                print(self.mySignals.S3_cmd_start)
                print("\tS3_cmd_stop =", end = " ")
                print(self.mySignals.S3_cmd_stop)
                print("\tS3_cmd_reset =", end = " ")
                print(self.mySignals.S3_cmd_reset)
                print("\tS3_batch_id =", end = " ")
                print(self.mySignals.S3_batch_id)
                print("\tS3_recipe_id =", end = " ")
                print(self.mySignals.S3_recipe_id)
                print("\tS4_cmd_start =", end = " ")
                print(self.mySignals.S4_cmd_start)
                print("\tS4_cmd_stop =", end = " ")
                print(self.mySignals.S4_cmd_stop)
                print("\tS4_cmd_reset =", end = " ")
                print(self.mySignals.S4_cmd_reset)
                print("\tS4_batch_id =", end = " ")
                print(self.mySignals.S4_batch_id)
                print("\tS4_recipe_id =", end = " ")
                print(self.mySignals.S4_recipe_id)
                print("\tS5_cmd_start =", end = " ")
                print(self.mySignals.S5_cmd_start)
                print("\tS5_cmd_stop =", end = " ")
                print(self.mySignals.S5_cmd_stop)
                print("\tS5_cmd_reset =", end = " ")
                print(self.mySignals.S5_cmd_reset)
                print("\tS5_batch_id =", end = " ")
                print(self.mySignals.S5_batch_id)
                print("\tS5_recipe_id =", end = " ")
                print(self.mySignals.S5_recipe_id)
                print("\tS6_cmd_start =", end = " ")
                print(self.mySignals.S6_cmd_start)
                print("\tS6_cmd_stop =", end = " ")
                print(self.mySignals.S6_cmd_stop)
                print("\tS6_cmd_reset =", end = " ")
                print(self.mySignals.S6_cmd_reset)
                print("\tS6_batch_id =", end = " ")
                print(self.mySignals.S6_batch_id)
                print("\tS6_recipe_id =", end = " ")
                print(self.mySignals.S6_recipe_id)
                print(f"  PLC State: {self._state}")
                print(f"  Done latches: S1={self._done_latched['S1']}, S2={self._done_latched['S2']}, S3={self._done_latched['S3']}, S4={self._done_latched['S4']}")
                print(f"  Start sent: S1={self._start_sent['S1']}, S2={self._start_sent['S2']}, S3={self._start_sent['S3']}, S4={self._start_sent['S4']}")
                print(f"  Buffers: S1_to_S2={self._buffers['S1_to_S2']}, S2_to_S3={self._buffers['S2_to_S3']}, S3_to_S4={self._buffers['S3_to_S4']}")
                print("\n\n")

                self.updateInternalVariables()

                if(vsiCommonPythonApi.isStopRequested()):
                    raise Exception("stopRequested")
                nextExpectedTime += self.simulationStep

                if(vsiCommonPythonApi.getSimulationTimeInNs() >= nextExpectedTime):
                    continue

                if(nextExpectedTime > self.totalSimulationTime):
                    remainingTime = self.totalSimulationTime - vsiCommonPythonApi.getSimulationTimeInNs()
                    vsiCommonPythonApi.advanceSimulation(remainingTime)
                    break

                vsiCommonPythonApi.advanceSimulation(nextExpectedTime - vsiCommonPythonApi.getSimulationTimeInNs())

            if(vsiCommonPythonApi.getSimulationTimeInNs() < self.totalSimulationTime):
                vsiEthernetPythonGateway.terminate()
        except Exception as e:
            if str(e) == "stopRequested":
                print("Terminate signal has been received from one of the VSI clients")
                vsiCommonPythonApi.advanceSimulation(self.simulationStep + 1)
            else:
                print(f"An error occurred: {str(e)}")
        except:
            vsiCommonPythonApi.advanceSimulation(self.simulationStep + 1)



    def establishTcpUdpConnection(self):
        if(self.clientPortNum[ST1_ComponentKitting0] == 0):
            self.clientPortNum[ST1_ComponentKitting0] = vsiEthernetPythonGateway.tcpListen(PLC_LineCoordinatorSocketPortNumber0)

        if(self.clientPortNum[ST2_FrameCoreAssembly1] == 0):
            self.clientPortNum[ST2_FrameCoreAssembly1] = vsiEthernetPythonGateway.tcpListen(PLC_LineCoordinatorSocketPortNumber1)

        if(self.clientPortNum[ST3_ElectronicsWiring2] == 0):
            self.clientPortNum[ST3_ElectronicsWiring2] = vsiEthernetPythonGateway.tcpListen(PLC_LineCoordinatorSocketPortNumber2)

        if(self.clientPortNum[ST4_CalibrationTesting3] == 0):
            self.clientPortNum[ST4_CalibrationTesting3] = vsiEthernetPythonGateway.tcpListen(PLC_LineCoordinatorSocketPortNumber3)

        if(self.clientPortNum[ST5_QualityInspection4] == 0):
            self.clientPortNum[ST5_QualityInspection4] = vsiEthernetPythonGateway.tcpListen(PLC_LineCoordinatorSocketPortNumber4)

        if(self.clientPortNum[ST6_PackagingDispatch5] == 0):
            self.clientPortNum[ST6_PackagingDispatch5] = vsiEthernetPythonGateway.tcpListen(PLC_LineCoordinatorSocketPortNumber5)

        # Print all listen handles for debugging
        print(f"PLC handles: ST1={self.clientPortNum[ST1_ComponentKitting0]}, ST2={self.clientPortNum[ST2_FrameCoreAssembly1]}, "
              f"ST3={self.clientPortNum[ST3_ElectronicsWiring2]}, ST4={self.clientPortNum[ST4_CalibrationTesting3]}, "
              f"ST5={self.clientPortNum[ST5_QualityInspection4]}, ST6={self.clientPortNum[ST6_PackagingDispatch5]}")

        if(self.clientPortNum[ST1_ComponentKitting0] == 0):
            print("Error: Failed to listen on TCP port:")
            print(PLC_LineCoordinatorSocketPortNumber0)
            exit()

        if(self.clientPortNum[ST2_FrameCoreAssembly1] == 0):
            print("Error: Failed to listen on TCP port:")
            print(PLC_LineCoordinatorSocketPortNumber1)
            exit()

        if(self.clientPortNum[ST3_ElectronicsWiring2] == 0):
            print("Error: Failed to listen on TCP port:")
            print(PLC_LineCoordinatorSocketPortNumber2)
            exit()

        if(self.clientPortNum[ST4_CalibrationTesting3] == 0):
            print("Error: Failed to listen on TCP port:")
            print(PLC_LineCoordinatorSocketPortNumber3)
            exit()

        if(self.clientPortNum[ST5_QualityInspection4] == 0):
            print("Error: Failed to listen on TCP port:")
            print(PLC_LineCoordinatorSocketPortNumber4)
            exit()

        if(self.clientPortNum[ST6_PackagingDispatch5] == 0):
            print("Error: Failed to listen on TCP port:")
            print(PLC_LineCoordinatorSocketPortNumber5)
            exit()


    def decapsulateReceivedData(self, receivedData):
        self.receivedDestPortNumber = receivedData[0]
        self.receivedSrcPortNumber = receivedData[1]
        self.receivedNumberOfBytes = receivedData[3]
        self.receivedPayload = [0] * (self.receivedNumberOfBytes)

        for i in range(self.receivedNumberOfBytes):
            self.receivedPayload[i] = receivedData[2][i]

        # DEBUG: Print packet metadata
        print(f"PLC RX meta dest/src/len: {self.receivedDestPortNumber}, {self.receivedSrcPortNumber}, {self.receivedNumberOfBytes}")

        # Store the ST1 client handle when we receive a packet from ST1
        if(self.receivedDestPortNumber == PLC_LineCoordinatorSocketPortNumber0):
            print("Received packet from ST1_ComponentKitting")
            
            st1_handle = self.receivedSrcPortNumber
            if st1_handle != 0 and st1_handle != self.station_handles["S1"]:
                print(f"  Storing ST1 handle: {st1_handle} (was {self.station_handles['S1']})")
                self.station_handles["S1"] = st1_handle
            
            receivedPayload = bytes(self.receivedPayload)
            self.mySignals.S1_ready, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S1_busy, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S1_fault, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S1_done, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S1_cycle_time_ms, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S1_inventory_ok, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S1_any_arm_failed, receivedPayload = self.unpackBytes('?', receivedPayload)

        if(self.receivedDestPortNumber == PLC_LineCoordinatorSocketPortNumber1):
            print("Received packet from ST2_FrameCoreAssembly")
            st2_handle = self.receivedSrcPortNumber
            if st2_handle != 0 and st2_handle != self.station_handles["S2"]:
                print(f"  Storing ST2 handle: {st2_handle}")
                self.station_handles["S2"] = st2_handle
                
            receivedPayload = bytes(self.receivedPayload)
            self.mySignals.S2_ready, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S2_busy, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S2_fault, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S2_done, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S2_cycle_time_ms, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S2_completed, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S2_scrapped, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S2_reworks, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S2_cycle_time_avg_s, receivedPayload = self.unpackBytes('d', receivedPayload)

        if(self.receivedDestPortNumber == PLC_LineCoordinatorSocketPortNumber2):
            print("Received packet from ST3_ElectronicsWiring")
            st3_handle = self.receivedSrcPortNumber
            if st3_handle != 0 and st3_handle != self.station_handles["S3"]:
                print(f"  Storing ST3 handle: {st3_handle}")
                self.station_handles["S3"] = st3_handle
                
            receivedPayload = bytes(self.receivedPayload)
            self.mySignals.S3_ready, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S3_busy, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S3_fault, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S3_done, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S3_cycle_time_ms, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S3_strain_relief_ok, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S3_continuity_ok, receivedPayload = self.unpackBytes('?', receivedPayload)

        if(self.receivedDestPortNumber == PLC_LineCoordinatorSocketPortNumber3):
            print("Received packet from ST4_CalibrationTesting")
            st4_handle = self.receivedSrcPortNumber
            if st4_handle != 0 and st4_handle != self.station_handles["S4"]:
                print(f"  Storing ST4 handle: {st4_handle}")
                self.station_handles["S4"] = st4_handle
                
            receivedPayload = bytes(self.receivedPayload)
            self.mySignals.S4_ready, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S4_busy, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S4_fault, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S4_done, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S4_cycle_time_ms, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S4_total, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S4_completed, receivedPayload = self.unpackBytes('L', receivedPayload)

        if(self.receivedDestPortNumber == PLC_LineCoordinatorSocketPortNumber4):
            print("Received packet from ST5_QualityInspection")
            st5_handle = self.receivedSrcPortNumber
            if st5_handle != 0 and st5_handle != self.station_handles["S5"]:
                print(f"  Storing ST5 handle: {st5_handle}")
                self.station_handles["S5"] = st5_handle
                
            receivedPayload = bytes(self.receivedPayload)
            self.mySignals.S5_ready, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S5_busy, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S5_fault, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S5_done, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S5_cycle_time_ms, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S5_accept, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S5_reject, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S5_last_accept, receivedPayload = self.unpackBytes('?', receivedPayload)

        if(self.receivedDestPortNumber == PLC_LineCoordinatorSocketPortNumber5):
            print("Received packet from ST6_PackagingDispatch")
            st6_handle = self.receivedSrcPortNumber
            if st6_handle != 0 and st6_handle != self.station_handles["S6"]:
                print(f"  Storing ST6 handle: {st6_handle}")
                self.station_handles["S6"] = st6_handle
                
            receivedPayload = bytes(self.receivedPayload)
            self.mySignals.S6_ready, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S6_busy, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S6_fault, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S6_done, receivedPayload = self.unpackBytes('?', receivedPayload)
            self.mySignals.S6_cycle_time_ms, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S6_packages_completed, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S6_arm_cycles, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S6_total_repairs, receivedPayload = self.unpackBytes('L', receivedPayload)
            self.mySignals.S6_operational_time_s, receivedPayload = self.unpackBytes('d', receivedPayload)
            self.mySignals.S6_downtime_s, receivedPayload = self.unpackBytes('d', receivedPayload)
            self.mySignals.S6_availability, receivedPayload = self.unpackBytes('d', receivedPayload)

    def sendEthernetPacketToST1_ComponentKitting(self):
        bytesToSend = bytes()
        bytesToSend += self.packBytes('?', self.mySignals.S1_cmd_start)
        bytesToSend += self.packBytes('?', self.mySignals.S1_cmd_stop)
        bytesToSend += self.packBytes('?', self.mySignals.S1_cmd_reset)
        bytesToSend += self.packBytes('L', self.mySignals.S1_batch_id)
        bytesToSend += self.packBytes('H', self.mySignals.S1_recipe_id)
        
        handle = self.station_handles["S1"]
        packet_len = len(bytesToSend)
        
        if handle == 0:
            print(f"PLC TX ST1: SKIPPING - no handle yet (need to receive from ST1 first)")
            return
            
        vsiEthernetPythonGateway.sendEthernetPacket(handle, bytes(bytesToSend))
        print(f"PLC->S1 send: cmd_start={self.mySignals.S1_cmd_start}, cmd_stop={self.mySignals.S1_cmd_stop}, cmd_reset={self.mySignals.S1_cmd_reset}")

    def sendEthernetPacketToST2_FrameCoreAssembly(self):
        bytesToSend = bytes()
        bytesToSend += self.packBytes('?', self.mySignals.S2_cmd_start)
        bytesToSend += self.packBytes('?', self.mySignals.S2_cmd_stop)
        bytesToSend += self.packBytes('?', self.mySignals.S2_cmd_reset)
        bytesToSend += self.packBytes('L', self.mySignals.S2_batch_id)
        bytesToSend += self.packBytes('H', self.mySignals.S2_recipe_id)
        handle = self.station_handles["S2"]
        if handle == 0:
            handle = self.clientPortNum[ST2_FrameCoreAssembly1]
        packet_len = len(bytesToSend)
        vsiEthernetPythonGateway.sendEthernetPacket(handle, bytes(bytesToSend))
        print(f"PLC->S2 send: cmd_start={self.mySignals.S2_cmd_start}, cmd_stop={self.mySignals.S2_cmd_stop}, cmd_reset={self.mySignals.S2_cmd_reset}")

    def sendEthernetPacketToST3_ElectronicsWiring(self):
        bytesToSend = bytes()
        bytesToSend += self.packBytes('?', self.mySignals.S3_cmd_start)
        bytesToSend += self.packBytes('?', self.mySignals.S3_cmd_stop)
        bytesToSend += self.packBytes('?', self.mySignals.S3_cmd_reset)
        bytesToSend += self.packBytes('L', self.mySignals.S3_batch_id)
        bytesToSend += self.packBytes('H', self.mySignals.S3_recipe_id)
        handle = self.station_handles["S3"]
        if handle == 0:
            handle = self.clientPortNum[ST3_ElectronicsWiring2]
        packet_len = len(bytesToSend)
        vsiEthernetPythonGateway.sendEthernetPacket(handle, bytes(bytesToSend))
        print(f"PLC->S3 send: cmd_start={self.mySignals.S3_cmd_start}, cmd_stop={self.mySignals.S3_cmd_stop}, cmd_reset={self.mySignals.S3_cmd_reset}")

    def sendEthernetPacketToST4_CalibrationTesting(self):
        bytesToSend = bytes()
        bytesToSend += self.packBytes('?', self.mySignals.S4_cmd_start)
        bytesToSend += self.packBytes('?', self.mySignals.S4_cmd_stop)
        bytesToSend += self.packBytes('?', self.mySignals.S4_cmd_reset)
        bytesToSend += self.packBytes('L', self.mySignals.S4_batch_id)
        bytesToSend += self.packBytes('H', self.mySignals.S4_recipe_id)
        handle = self.station_handles["S4"]
        if handle == 0:
            handle = self.clientPortNum[ST4_CalibrationTesting3]
        packet_len = len(bytesToSend)
        vsiEthernetPythonGateway.sendEthernetPacket(handle, bytes(bytesToSend))
        print(f"PLC->S4 send: cmd_start={self.mySignals.S4_cmd_start}, cmd_stop={self.mySignals.S4_cmd_stop}, cmd_reset={self.mySignals.S4_cmd_reset}")

    def sendEthernetPacketToST5_QualityInspection(self):
        bytesToSend = bytes()
        bytesToSend += self.packBytes('?', self.mySignals.S5_cmd_start)
        bytesToSend += self.packBytes('?', self.mySignals.S5_cmd_stop)
        bytesToSend += self.packBytes('?', self.mySignals.S5_cmd_reset)
        bytesToSend += self.packBytes('L', self.mySignals.S5_batch_id)
        bytesToSend += self.packBytes('H', self.mySignals.S5_recipe_id)
        handle = self.station_handles["S5"]
        if handle == 0:
            handle = self.clientPortNum[ST5_QualityInspection4]
        packet_len = len(bytesToSend)
        vsiEthernetPythonGateway.sendEthernetPacket(handle, bytes(bytesToSend))

    def sendEthernetPacketToST6_PackagingDispatch(self):
        bytesToSend = bytes()
        bytesToSend += self.packBytes('?', self.mySignals.S6_cmd_start)
        bytesToSend += self.packBytes('?', self.mySignals.S6_cmd_stop)
        bytesToSend += self.packBytes('?', self.mySignals.S6_cmd_reset)
        bytesToSend += self.packBytes('L', self.mySignals.S6_batch_id)
        bytesToSend += self.packBytes('H', self.mySignals.S6_recipe_id)
        handle = self.station_handles["S6"]
        if handle == 0:
            handle = self.clientPortNum[ST6_PackagingDispatch5]
        packet_len = len(bytesToSend)
        vsiEthernetPythonGateway.sendEthernetPacket(handle, bytes(bytesToSend))



    def packBytes(self, signalType, signal):
        if isinstance(signal, list):
            if signalType == 's':
                packedData = b''
                for str in signal:
                    str += '\0'
                    str = str.encode('utf-8')
                    packedData += struct.pack(f'={len(str)}s', str)
                return packedData
            else:
                return struct.pack(f'={len(signal)}{signalType}', *signal)
        else:
            if signalType == 's':
                signal += '\0'
                signal = signal.encode('utf-8')
                return struct.pack(f'={len(signal)}s', signal)
            else:
                return struct.pack(f'={signalType}', signal)

    def unpackBytes(self, signalType, packedBytes, signal = ""):
        if isinstance(signal, list):
            if signalType == 's':
                unpackedStrings = [''] * len(signal)
                for i in range(len(signal)):
                    nullCharacterIndex = packedBytes.find(b'\0')
                    if nullCharacterIndex == -1:
                        break
                    unpackedString = struct.unpack(f'={nullCharacterIndex}s', packedBytes[:nullCharacterIndex])[0].decode('utf-8')
                    unpackedStrings[i] = unpackedString
                    packedBytes = packedBytes[nullCharacterIndex + 1:]
                return unpackedStrings, packedBytes
            else:
                unpackedVariable = struct.unpack(f'={len(signal)}{signalType}', packedBytes[:len(signal)*struct.calcsize(f'={signalType}')])
                packedBytes = packedBytes[len(unpackedVariable)*struct.calcsize(f'={signalType}'):]
                return list(unpackedVariable), packedBytes
        elif signalType == 's':
            nullCharacterIndex = packedBytes.find(b'\0')
            unpackedVariable = struct.unpack(f'={nullCharacterIndex}s', packedBytes[:nullCharacterIndex])[0].decode('utf-8')
            packedBytes = packedBytes[nullCharacterIndex + 1:]
            return unpackedVariable, packedBytes
        else:
            numBytes = 0
            if signalType in ['?', 'b', 'B']:
                numBytes = 1
            elif signalType in ['h', 'H']:
                numBytes = 2
            elif signalType in ['f', 'i', 'I', 'L', 'l']:
                numBytes = 4
            elif signalType in ['q', 'Q', 'd']:
                numBytes = 8
            else:
                raise Exception('received an invalid signal type in unpackBytes()')
            unpackedVariable = struct.unpack(f'={signalType}', packedBytes[0:numBytes])[0]
            packedBytes = packedBytes[numBytes:]
            return unpackedVariable, packedBytes

    def updateInternalVariables(self):
        self.totalSimulationTime = vsiCommonPythonApi.getTotalSimulationTime()
        self.stopRequested = vsiCommonPythonApi.isStopRequested()
        self.simulationStep = vsiCommonPythonApi.getSimulationStep()



def main():
    inputArgs = argparse.ArgumentParser(" ")
    inputArgs.add_argument('--domain', metavar='D', default='AF_UNIX', help='Socket domain for connection with the VSI TLM fabric server')
    inputArgs.add_argument('--server-url', metavar='CO', default='localhost', help='server URL of the VSI TLM Fabric Server')

    args = inputArgs.parse_args()

    pLC_LineCoordinator = PLC_LineCoordinator(args)
    pLC_LineCoordinator.mainThread()



if __name__ == '__main__':
    main()
